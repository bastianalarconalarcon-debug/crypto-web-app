<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Crypto App - Dos campanas y brackets</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    .band { opacity: 0.15; }
  </style>
</head>
<body class="bg-light">
<div class="container py-4">
  <h3 class="mb-3">Cripto Velas → Dos campanas (High / Low) con brackets</h3>
  <form id="form" class="row g-3 mb-3">
    <div class="col-sm-3">
      <label class="form-label">Símbolo</label>
      <input id="symbol" class="form-control" value="BTCUSDT" />
    </div>
    <div class="col-sm-3">
      <label class="form-label">Intervalo</label>
      <select id="interval" class="form-select">
        <option>1m</option><option>3m</option><option>5m</option><option>15m</option>
        <option>30m</option><option>1h</option><option>2h</option><option>4h</option>
        <option>6h</option><option>8h</option><option>12h</option><option>1d</option>
        <option>3d</option><option>1w</option><option>1M</option>
      </select>
    </div>
    <div class="col-sm-2">
      <label class="form-label">Velas (10-1000)</label>
      <input id="limit" type="number" class="form-control" value="500" min="10" max="1000" />
    </div>
    <div class="col-sm-2 align-self-end">
      <button class="btn btn-primary w-100">Actualizar</button>
    </div>
  </form>
  <div class="row">
    <div class="col-lg-6 mb-4">
      <div class="card">
        <div class="card-header">High: Histograma + Gauss</div>
        <div class="card-body">
          <canvas id="chartHigh" height="260"></canvas>
          <div class="small text-muted mt-2" id="infoHigh"></div>
        </div>
      </div>
    </div>
    <div class="col-lg-6 mb-4">
      <div class="card">
        <div class="card-header">Low: Histograma + Gauss</div>
        <div class="card-body">
          <canvas id="chartLow" height="260"></canvas>
          <div class="small text-muted mt-2" id="infoLow"></div>
        </div>
      </div>
    </div>
  </div>
  <div id="error" class="alert alert-danger d-none"></div>
  <p class="text-muted mt-3">Esta aplicación se ejecuta íntegramente en tu navegador hablando con el backend FastAPI (mismo dominio).</p>
</div>
<script>
const BACKEND_BASE = ""; // API endpoints en el mismo host
let chartHigh, chartLow;

function gaussian(x, mu, sigma) {
  const a = 1 / (sigma * Math.sqrt(2 * Math.PI));
  const e = Math.exp(-0.5 * ((x - mu) / sigma) ** 2);
  return a * e;
}

function linspace(min, max, n = 200) {
  const out = [];
  const step = (max - min) / (n - 1);
  for (let i = 0; i < n; i++) out.push(min + i * step);
  return out;
}

function makeHistogram(arr, bins = 30) {
  const min = Math.min(...arr), max = Math.max(...arr);
  if (!isFinite(min) || !isFinite(max) || min === max) {
    return { binEdges: [0, 1], counts: [arr.length] };
  }
  const edges = linspace(min, max, bins + 1);
  const counts = new Array(bins).fill(0);
  for (const v of arr) {
    if (!isFinite(v)) continue;
    let idx = Math.floor((v - min) / (max - min) * bins);
    if (idx === bins) idx = bins - 1;
    counts[idx]++;
  }
  return { binEdges: edges, counts };
}

function datasetForHistogram(edges, counts) {
  const labels = [];
  const values = [];
  for (let i = 0; i < counts.length; i++) {
    labels.push((edges[i] + edges[i + 1]) / 2.0);
    values.push(counts[i]);
  }
  return { labels, values };
}

function bracketBands(mu, sigma) {
  return [
    { label: "68%", from: mu - sigma, to: mu + sigma, color: "rgba(0,200,0,0.18)" },
    { label: "95%", from: mu - 2 * sigma, to: mu + 2 * sigma, color: "rgba(255,165,0,0.18)" },
    { label: "99.7%", from: mu - 3 * sigma, to: mu + 3 * sigma, color: "rgba(255,99,132,0.18)" },
  ];
}

function drawChart(canvasId, infoId, arr, mu, sigma, title) {
  const bins = 30;
  const { binEdges, counts } = makeHistogram(arr, bins);
  const { labels, values } = datasetForHistogram(binEdges, counts);
  const xs = linspace(labels[0], labels[labels.length - 1], 200);
  const pdf = xs.map(x => gaussian(x, mu, sigma));
  const maxCount = Math.max(...values, 1);
  const maxPdf = Math.max(...pdf, 1e-9);
  const scale = maxCount / maxPdf;
  const pdfScaled = pdf.map(v => v * scale);
  const bands = (isFinite(mu) && isFinite(sigma) && sigma > 0) ? bracketBands(mu, sigma) : [];
  if (canvasId === "chartHigh" && chartHigh) chartHigh.destroy();
  if (canvasId === "chartLow" && chartLow) chartLow.destroy();
  const ctx = document.getElementById(canvasId).getContext("2d");
  const cfg = {
    type: "line",
    data: {
      labels,
      datasets: [
        {
          label: "Histograma",
          data: values,
          type: "bar",
        },
        {
          label: "Gauss μ±σ",
          data: xs.map((x, i) => ({ x, y: pdfScaled[i] })),
          parsing: false,
          pointRadius: 0,
          borderWidth: 2,
        }
      ]
    },
    options: {
      responsive: true,
      plugins: {
        title: { display: true, text: title },
        legend: { display: true },
      },
      scales: {
        x: { type: 'linear', title: { display: true, text: 'Precio' } },
        y: { title: { display: true, text: 'Frecuencia' } },
      },
    },
    plugins: [{
      id: "bands",
      afterDatasetsDraw(chart) {
        const { ctx, scales: { x, y } } = chart;
        bands.forEach(b => {
          if (!isFinite(b.from) || !isFinite(b.to)) return;
          const x1 = x.getPixelForValue(b.from);
          const x2 = x.getPixelForValue(b.to);
          ctx.save();
          ctx.fillStyle = b.color;
          ctx.fillRect(Math.min(x1, x2), y.top, Math.abs(x2 - x1), y.bottom - y.top);
          ctx.restore();
        });
      }
    }]
  };
  const instance = new Chart(ctx, cfg);
  if (canvasId === "chartHigh") chartHigh = instance;
  if (canvasId === "chartLow") chartLow = instance;
  const info = document.getElementById(infoId);
  info.innerHTML = (isFinite(mu) && isFinite(sigma))
    ? `μ = ${mu.toFixed(4)} | σ = ${sigma.toFixed(4)} · 68%: [${(mu - sigma).toFixed(4)}, ${(mu + sigma).toFixed(4)}]`
    : `No hay suficientes datos para estimar μ/σ`;
}

async function fetchJSON(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return r.json();
}

async function load() {
  const symbol = document.getElementById("symbol").value.trim().toUpperCase();
  const interval = document.getElementById("interval").value;
  const limit = parseInt(document.getElementById("limit").value, 10);
  const errorBox = document.getElementById("error");
  errorBox.classList.add("d-none"); errorBox.textContent = "";
  try {
    const stats = await fetchJSON(`${BACKEND_BASE}/api/stats?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`);
    const kl = await fetchJSON(`${BACKEND_BASE}/api/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`);
    const highs = kl.rows.map(r => r.high);
    const lows = kl.rows.map(r => r.low);
    drawChart("chartHigh", "infoHigh", highs, stats.gauss_high.mu, stats.gauss_high.sigma, `High · ${stats.symbol} · ${stats.interval} · n=${stats.n}`);
    drawChart("chartLow", "infoLow", lows, stats.gauss_low.mu, stats.gauss_low.sigma, `Low · ${stats.symbol} · ${stats.interval} · n=${stats.n}`);
  } catch (err) {
    errorBox.textContent = err.message;
    errorBox.classList.remove("d-none");
  }
}

document.getElementById("form").addEventListener("submit", ev => {
  ev.preventDefault();
  load();
});
</script>
</body>
</html>
